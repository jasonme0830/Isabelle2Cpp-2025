## 现状

类型的确定目前依赖两个方面：
1. 在生成过程中，由函数规范的参数和返回值类型，获得其它类型信息
2. 在生成的 C++ 代码中，由 C++ 的 `auto` 和 `decltype` 自动推导获得一些类型信息

## 表达式的类型不包含子表达式的类型时可能类型缺失

```
fun test :: "'a list \<Rightarrow> nat" where
  "test Nil = 0" |
  "test (Cons x xs) = length (If ((length xs) = 0) Nil xs) + 1"
```

```
template<typename T1>
std::uint64_t test(const std::list<T1> &arg1) {
    ...
    // test (Cons x xs) = length (If ((length xs) = 0) Nil xs) + 1
    if (!arg1.empty()) {
        auto xs = decltype(arg1){std::next(arg1.begin()), arg1.end()};
        UNKNOWN_TYPE temp0;
        if (xs.size() == 0) {
            temp0 = {};
        } else {
            temp0 = xs;
        }
        return temp0.size() + 1;
    } else { // auto-generated for -Wreturn-type
        std::abort();
    }
}
```

- 目前表达式生成时，子表达式的类型根据根表达式的类型推导
- 目前只有规范中定义的函数有类型信息
- 一些预定义的函数 `length` 没有记录类型信息
- 只知道 `length (...)` 的类型是 `nat`，不知道其参数的类型
