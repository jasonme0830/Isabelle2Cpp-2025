# 对象的重用

> 尽量消除函数调用时产生的拷贝

## 自定义类型

自定义的类型，转换后的 C++ 类型也是递归定义的。因此，在此基础上的函数定义也是递归的，已构造的值是不变的，并且节点的指针可以共享，因此应尽量避免节点的拷贝，而在函数调用时，传递的都是节点。故函数的形参使用 const 引用和值传递的区别不大，都需要在构建新值时进行值的拷贝，但是应尽可能将节点的拷贝延迟在值的构造时候，因此应尽可能使用 const 引用传递值。

## 已有类型

已有类型（比如 list），转换为 C++ 中的 `std::list`，由于后者一个对象中的所有节点都属于一个 `std::list` 对象，每次传递引用时，如果要通过 `x # xs` 使用第一个节点之后的值，就需要将后边的所有节点进行拷贝，因此，应避免使用引用传递，需要考虑值的修改和移动。同时，如果表达式中出现了两次 `xs`，即使使用引用传递，在过程中也无法避免对 `xs` 的拷贝。

由于 `list` 常用的操作都进行了到 `std::list` 对应方法的转换，在用户定义规范时，只会使用 `list` 的模式为 `[]` 和 `x # xs`，后者在递归时，如果每次都使用引用传递，则每次递归调用时都需要拷贝 `xs`。而值传递（通过移动传值），只可能在表达式中出现多次 `xs` 时发生拷贝。同时，由于内建函数转换为方法，因此，在通过内建函数调用时，不会发生拷贝。因此，`xs` 的拷贝只在调用用户定义的函数时发生。

**注意**，如果值是 `move` 的，需要考虑模式匹配时不满足时值的问题：当模式 `(x # xs) (y # ys)` 在前，而 `[] (y # ys)` 在后时，深度优先地递归生成条件和变量声明 `auto x = arg1.front(); arg1.pop_front(); auto xs = std::move(arg1);` 会导致 `arg1` 在后续 CSM 中不再可用。一个可行的方法是，将变量的声明语句延迟到所有条件生成后进行生成，在这个过程中，条件的生成不能够导致值的移动和修改，也即，值的原地修改和移动只能在变量声明语句时发生，而变量声明语句需要在所有条件判断完成后才能够生成。

## 实验

记录后者比前者提升多少
