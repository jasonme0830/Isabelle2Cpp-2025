# 递归转循环

## 简单直接的递归转循环方法

一个简单直接的想法是，手动地模拟递归函数的执行。在这一过程中，需要处理参数、返回值、局部变量和控制流。

## 递归 => 尾递归 => 循环

### 尾递归转循环

尾递归是递归的一种特殊形式，也是较为容易进行优化的情况。因此首先考虑尾递归时，递归转循环的转换方法。

样例见 [ft2_loop](tail2loop.cpp)。对于尾递归，只需要将递归调用替换为更新参数值和 `continue` 即可。

> 现代编译器中，这些尾递归可以被编译器优化（通过检查生成的汇编中是否包含对应的 `call` 指令）。

### 普通递归转尾递归

尾递归可以转换为循环，因此如果存在将普通递归转换为尾递归的方法，就可以将普通递归函数优化为循环。

对于人工实现简单递归实例的转换，可能引入累加器就可以实现，样例见 [recursive2tail.cpp](recursive2tail.cpp)，但是转换过程需要求解运算的单位元，同时终止条件时返回值与累加器的运算需要人工推理，这意味着此类转换方法无法自动进行 (见 [factorial_termial](recursive2tail.cpp) 和 [ft2](recursive2tail.cpp))。

> 事实上，编译器也能够优化 `factorial_termial` 这样的函数（并非通过上面的方法），使生成的汇编中不包含函数调用。

考虑引入函数式语言中的 `Continuation`。也即，在调用递归函数时，将当前的后续执行打包成一个闭包 `continuation` 传递给被调用的函数，函数在计算完成后，将结果传递给该闭包继续执行，然后返回，整个函数实现就变成了尾递归。这样一来，就可以使用优化尾递归的方法，将此递归函数转换为循环。

首先考虑直接使用 lambda-expression 将递归调用后的操作封装成一个闭包，同时捕获之后操作中使用到的变量。样例见 [ft3](recursive2tail.cpp)。尽管这样的函数已经被转换成了一个尾递归函数，同时我们可以得到它的循环版本 [ft3_loop](tail2loop.cpp)。可以发现，尽管 `ft3_loop` 不再是一个递归函数，但是通过不断地构造 `continuation`，并且 `continuation` 中可能捕获了之前调用时的 `continuation`，尾递归事实上被转移到了 `continuation` 的调用过程当中，并且这一过程没有被编译器优化（尽管在实现中，同一行构造的闭包可能是接受了不同参数的同一个函数）。尽管这样的尝试失败了（事实上，当递归调用后存在另一个递归调用时，使用这一方法进行转换会存在一些困难，因为递归调用不再是链而是树），但是可以发现，在构造 `continuation` 的过程中，其实是将递归调用后，操作和其依赖的变量压栈，而在调用上层的 `continuation` 时，则是将变量和返回值以及操作出栈后继续运算。而这两部分可以通过栈和状态机实现，从而避免使用函数调用。

> 本质和上面的通用算法是相同的。

## 对比

经过简单测试，对于函数 `factorial_termial` 的递归版和循环修改版 `ft4_loop` 进行测试，后者运行需要的时间约前者的六倍。

## 需要解决的问题

- 扫描递归调用后使用到的变量
- 遇到 if-else 结构时，后面相同的代码如何处理
