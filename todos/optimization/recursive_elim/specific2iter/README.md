# 针对特定模式的递归转迭代的自底向上方法

自底向上也即从终止条件的返回值和参数出发，不断地**求解参数**，同时更新返回值，直到计算得到的参数（记为*估计参数*）和**原始参数**相同时，返回对应的返回值。

在这一过程中，如果递归调用时的参数是由参数（或者模式匹配解包出来的变量）经过计算得到的，需要这一过程的**逆计算**，如果只依赖解包的参数，则只需要将模式当做表达式处理，即可求解参数。

同时这一方法，需要**估计参数**能够和原始参数进行比较，意味着求解参数的过程只依赖模式的运算，而不依赖模式中，未在返回时使用的变量。

## 单参数

### 单终止条件和单次递归调用

```
fact 0 = 1
fact (Suc n) = (Suc n) * (fact n)
```

```
appro = 0; res = 1

appro = 0 -> n = 0
res = 1 -> (fact n) = 1

appro = Suc 0
res = (Suc 0) * 1
```

#### 反例

> 参数存在未知部分，无法通过自底向上的过程构造

```
length [] = 0
length x # xs = (length xs) + 1
```

```
appro = []; res = 0

appro = [] -> xs = []
res = 0 -> (length xs) = 0

appro = x # [] // `x` 依赖自顶向下传递的参数
res = 0 + 1
```

### 多终止条件和单次递归调用

多条件单调用时，原始参数只对应其中一个终止条件。可以同时维护以这些终止条件为起点的求解过程，直到其中一个的估计参数与原始参数相等。

```
fact 0 = 1
fact 1 = 1
fact (Suc (Suc n)) = (Suc n) * (fact n)
```

```
appro = 0; res = 1

appro = 0 -> n = 0
res = 1 -> (fact n) = 1

appro = Suc (Suc 0)
res = (Suc 0) * 1

---

appro = 1; res = 1

appro = 1 -> n = 1
res = 1 -> (fact n) = 1

appro = Suc (Suc 1)
res = (Suc 1) * 1
```

### 单终止条件和多次递归调用

单条件多调用时，一般不同的调用的实参不相同，实参由调用者的参数计算得到。

```
foo 0 = 1
foo n = (foo (n / 2)) + (foo (n - 1))
```

### 多终止条件和多次递归调用
