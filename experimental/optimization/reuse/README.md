# 对象的重用

> 尽量消除函数调用时产生的拷贝

## 自定义类型

自定义的类型，转换后的 C++ 类型也是递归定义的。因此，在此基础上的函数定义也是递归的，已构造的值是不变的，并且节点的指针可以共享，因此应尽量避免节点的拷贝，而在函数调用时，传递的都是节点。故函数的形参应使用 const 引用。

## 已有类型

已有类型（比如 list），转换为 C++ 中的 `std::list`，由于后者一个对象中的所有节点都属于一个 `std::list` 对象，每次传递引用时，如果要通过 `x # xs` 使用第一个节点之后的值，就需要将后边的所有节点进行拷贝，因此，应避免使用引用传递。同时，如果表达式中出现了两次 `xs`，即使使用引用传递，在过程中也无法避免对 `xs` 的拷贝。

由于 `list` 常用的操作都进行了到 `std::list` 对应方法的转换，在用户定义规范时，只会使用 `list` 的模式为 `[]` 和 `x # xs`，后者在递归时，如果每次都使用引用传递，则每次递归调用时都需要拷贝 `xs`。而值传递（通过移动传值），只可能在表达式中出现多次 `xs` 时发生拷贝。同时，由于内建函数转换为方法，因此，在通过内建函数调用时，不会发生拷贝。因此，`xs` 的拷贝只在调用用户定义的函数时发生。
