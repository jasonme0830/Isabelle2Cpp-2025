#include "synthesizer.hpp"
#include "../utility/config.hpp"

using namespace std;

namespace hol2cpp {
Synthesizer::Synthesizer(string filename)
  : filename_(move(filename))
  , out_(header_out_)
  , indent_(0)
{
  header_out_ = ofstream(filename_ + ".hpp");
  if (!header_out_.good()) {
    cout << "can't open file " << filename << ".hpp" << endl;
    return;
  }
  impl_out_ = ofstream(filename_ + ".cpp");
  if (!impl_out_.good()) {
    cout << "can't open file " << filename << ".cpp" << endl;
    return;
  }
}

void
Synthesizer::synthesize(const Code& code)
{
  syn_header(code);
  syn_impl(code);
}

void
Synthesizer::syn_header(const Code& code)
{
  out_ = ref(header_out_);

  for (const auto& header : code.headers()) {
    "#include <$>\n"_fs.outf(out_.get(), header);
  }
  out_.get() << endl;

  for (auto& datatype : code.datatypes()) {
    // pass predefs
    if (datatype.get().is_predef()) {
      continue;
    }

    syn_class(datatype);
  }

  for (auto& func : code.func_entities()) {
    // pass predefs
    if (func.get().is_predef()) {
      continue;
    }

    if (func.get().template_args().empty()) {
      syn_func(func, false);
    } else {
      syn_func(func, true);
    }
  }
  out_.get() << "// generated by HOL2Cpp" << endl;
}

void
Synthesizer::syn_impl(const Code& code)
{
  out_ = ref(impl_out_);

  "#include \"$\"\n\n"_fs.outf(
    out_.get(), filename_.substr(filename_.rfind('/') + 1) + ".hpp");

  for (auto& func : code.func_entities()) {
    // pass predefs
    if (func.get().is_predef()) {
      continue;
    }

    if (func.get().template_args().empty()) {
      syn_func(func);
    }
  }

  out_.get() << "// generated by HOL2Cpp" << endl;
}

void
Synthesizer::syn_class(const Datatype& datatype)
{
  indent_ = 0;
  if (!datatype.is_normal_type()) {
    syn_class_template(datatype);
  }
  syn_class_definition(datatype);
}

void
Synthesizer::syn_class_template(const Datatype& datatype)
{
  auto& targs = datatype.template_args();
  "template<"_fs.outf(newline());
  for (size_t i = 0; i < targs.size(); ++i) {
    if (i == 0) {
      "typename $"_fs.outf(out_.get(), targs[i]);
    } else {
      ", typename $"_fs.outf(out_.get(), targs[i]);
    }
  }
  ">\n"_fs.outf(out_.get());
}

void
Synthesizer::syn_class_definition(const Datatype& datatype)
{
  auto use_class = theConfig.use_class();

  auto& name = datatype.name();
  auto& self = datatype.self();
  auto& constructors = datatype.constructors();

  TypeInfo variant("std::variant");

  if (use_class) {
    "class $ {\n"_fs.outf(newline(), name);
  } else {
    "struct $ {\n"_fs.outf(newline(), name);
  }

  add_indent();
  auto& components = datatype.components();

  // generate struct _Ci { ... };
  for (size_t i = 0; i < components.size(); ++i) {
    variant.arguments.emplace_back("_$"_fs.format(constructors[i]));

    if (components[i].empty()) {
      "struct _$ {\n"_fs.outf(newline(), constructors[i]);
      add_indent();
      "bool operator<(const _$ &) const { return false; }\n"_fs.outf(
        newline(), constructors[i]);
      sub_indent();
      "};\n"_fs.outf(newline());
    } else {
      "struct _$ {\n"_fs.outf(newline(), constructors[i]);
      add_indent();

      // for operator<
      string lhs, rhs;

      // generate members
      for (size_t j = 0; j < components[i].size(); ++j) {
        if (j) {
          lhs += ", ";
          rhs += ", ";
        }

        if (components[i][j] == self) {
          "std::shared_ptr<$> p$_;\n"_fs.outf(
            newline(), components[i][j], j + 1);

          lhs.push_back('*');
          rhs.push_back('*');
        } else {
          "$ p$_;\n"_fs.outf(newline(), components[i][j], j + 1);
        }

        lhs += "p$_"_fs.format(j + 1);
        rhs += "rhs.p$_"_fs.format(j + 1);
      }
      out_.get() << endl;

      // generate methods
      for (size_t j = 0; j < components[i].size(); ++j) {
        if (components[i][j] == self) {
          "$ p$() const { return *p$_; }\n"_fs.outf(
            newline(), components[i][j], j + 1, j + 1);
        } else {
          "const $ &p$() const { return p$_; }\n"_fs.outf(
            newline(), components[i][j], j + 1, j + 1);
        }
      }
      out_.get() << endl;

      // generate operator<
      "bool operator<(const _$ &rhs) const {\n"_fs.outf(newline(),
                                                        constructors[i]);
      add_indent();
      "return std::tie($) < std::tie($);\n"_fs.outf(newline(), lhs, rhs);
      sub_indent();
      "}\n"_fs.outf(newline());

      sub_indent();
      "};\n"_fs.outf(newline());
    }
  }
  out_.get() << endl;

  // generate std::variant<_C0, ..., _Ck> value_;
  if (use_class) {
    "$ value_;\n"_fs.outf(newline(), variant.to_str());
    "$($value) : value_(value) {}\n\n"_fs.outf(
      newline(), name, variant.to_str_as_arg());
    "public:\n"_fs.outf(newline(-2));
    "$() = default;\n\n"_fs.outf(newline(), name);
  } else {
    "$ value_;\n\n"_fs.outf(newline(), variant.to_str());
  }

  // generate static constructions
  for (size_t i = 0; i < components.size(); ++i) {
    "static $ $("_fs.outf(newline(), self, constructors[i]);
    for (size_t j = 0; j < components[i].size(); ++j) {
      if (j == 0) {
        "const $ &p1"_fs.outf(out_.get(), components[i][j]);
        ;
      } else {
        ", const $ &p$"_fs.outf(out_.get(), components[i][j], j + 1);
      }
    }
    ") {\n"_fs.outf(out_.get());
    add_indent();

    "return $ { _$ { "_fs.outf(newline(), self, constructors[i]);
    for (size_t j = 0; j < components[i].size(); ++j) {
      if (components[i][j] == self) {
        if (j == 0) {
          "std::make_shared<$>(p1)"_fs.outf(out_.get(), self);
        } else {
          ", std::make_shared<$>(p$)"_fs.outf(out_.get(), self, j + 1);
        }
      } else {
        if (j == 0) {
          "p1"_fs.outf(out_.get());
        } else {
          ", p$"_fs.outf(out_.get(), j + 1);
        }
      }
    }
    " } };\n"_fs.outf(out_.get());

    sub_indent();
    "}\n"_fs.outf(newline());
  }

  // generate is_Ci()
  out_.get() << endl;
  for (auto& constructor : constructors) {
    "bool is_$() const { return std::holds_alternative<_$>(value_); }\n"_fs
      .outf(newline(), constructor, constructor);
  }

  // generate as_Ci()
  bool need_as_methods = false;
  for (size_t i = 0; i < components.size(); ++i) {
    if (!components[i].empty()) {
      need_as_methods = true;
      break;
    }
  }

  if (need_as_methods) {
    out_.get() << endl;
    for (size_t i = 0; i < components.size(); ++i) {
      if (!components[i].empty()) {
        "const _$ &as_$() const { return std::get<_$>(value_); }\n"_fs.outf(
          newline(), constructors[i], constructors[i], constructors[i]);
      }
    }
  }

  // generate operator<
  out_.get() << endl;
  "bool operator<(const $ &rhs) const { return value_ < rhs.value_; }\n"_fs
    .outf(newline(), self);

  sub_indent();
  "};\n\n"_fs.outf(newline());
}

void
Synthesizer::syn_func(const FuncEntity& func, bool is_impl)
{
  indent_ = 0;
  if (!func.template_args().empty()) {
    syn_func_template(func);
  }
  syn_func_definition(func, is_impl);
}

void
Synthesizer::syn_func_template(const FuncEntity& func)
{
  auto& template_args = func.template_args();
  "template<"_fs.outf(newline());
  for (size_t i = 0; i < template_args.size(); ++i) {
    if (i == 0) {
      "typename $"_fs.outf(out_.get(), template_args[i]);
    } else {
      ", typename $"_fs.outf(out_.get(), template_args[i]);
    }
  }
  ">\n"_fs.outf(out_.get());
}

void
Synthesizer::syn_func_definition(const FuncEntity& func, bool is_impl)
{
  auto params = syn_func_params(func);
  auto result_type = func.result_typeinfo().to_str();

  "$ $($)"_fs.outf(newline(), result_type, func.name(), params);

  if (!is_impl) {
    ";\n\n"_fs.outf(out_.get());
    return;
  }

  " {\n"_fs.outf(out_.get());
  add_indent();
  {
    if (func.memoize()) {
      "auto impl = [&]() -> $ {\n"_fs.outf(newline(), result_type);
      add_indent();
    }

    syn_func_body(func);

    if (func.memoize()) {
      sub_indent();
      "};\n\n"_fs.outf(newline());

      auto param_types = syn_func_param_types(func);
      auto args = syn_func_args(func);

      "static std::map<std::tuple<$>, $> cache;\n"_fs.outf(
        newline(), param_types, result_type);
      "auto args = std::make_tuple($);\n"_fs.outf(newline(), args);
      "auto it = cache.find(args);\n"_fs.outf(newline());
      "return it != cache.end() ? it->second : (cache.emplace(std::move(args), impl()).first->second);\n"_fs
        .outf(newline());
    }
  }
  sub_indent();
  "}\n\n"_fs.outf(newline());
}

void
Synthesizer::syn_func_body(const FuncEntity& func)
{
  auto& statements = func.statements();
  for (size_t i = 0; i < statements.size(); ++i) {
    if (i) {
      "\n"_fs.outf(out_.get());
    }

    for (auto& statement : statements[i]) {
      if (!statement.empty()) {
        newline() << statement << endl;
      }
    }
  }
}

string
Synthesizer::syn_func_params(const FuncEntity& func)
{
  string params;
  auto& types = func.typeinfos();
  for (size_t i = 0; i < types.size() - 1; ++i) {
    if (i) {
      params += ", ";
    }
    params += "$arg$"_fs.format(types[i].to_str_as_arg(), i + 1);
  }
  return params;
}

string
Synthesizer::syn_func_param_types(const FuncEntity& func)
{
  string param_types;
  auto& types = func.typeinfos();
  for (size_t i = 0; i < types.size() - 1; ++i) {
    if (i) {
      param_types += ", ";
    }
    param_types += "$"_fs.format(types[i].to_str());
  }
  return param_types;
}

string
Synthesizer::syn_func_args(const FuncEntity& func)
{
  string args;
  auto& types = func.typeinfos();
  for (size_t i = 0; i < types.size() - 1; ++i) {
    if (i) {
      args += ", ";
    }
    args += "arg$"_fs.format(i + 1);
  }
  return args;
}

ostream&
Synthesizer::newline(int more_indent)
{
  out_.get() << string(indent_ + more_indent, ' ');
  return out_.get();
}

void
Synthesizer::add_indent()
{
  indent_ += theIndentSize;
}

void
Synthesizer::sub_indent()
{
  indent_ -= theIndentSize;
}
} // namespace hol2cpp
