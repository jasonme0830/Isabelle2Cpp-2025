#include "synthesizer.hpp"
#include "../utility/config.hpp"

using namespace std;

namespace hol2cpp {
Synthesizer::Synthesizer(string filename)
  : filename_(move(filename))
  , out_(header_out_)
  , indent_(0)
{
  header_out_ = ofstream(filename_ + ".hpp");
  if (!header_out_.good()) {
    cout << "can't open file " << filename << ".hpp" << endl;
    return;
  }
  impl_out_ = ofstream(filename_ + ".cpp");
  if (!impl_out_.good()) {
    cout << "can't open file " << filename << ".cpp" << endl;
    return;
  }
}

void
Synthesizer::synthesize(const Code& code)
{
  syn_header(code);
  syn_impl(code);
}

void
Synthesizer::syn_header(const Code& code)
{
  out_ = ref(header_out_);

  for (const auto& header : code.headers()) {
    "#include <$>\n"_fs.outf(out_.get(), header);
  }
  out_.get() << endl;

  for (auto& datatype : code.datatypes()) {
    // pass predefs
    if (datatype.get().is_predef()) {
      continue;
    }

    syn_class(datatype);
  }

  //Gen typedef for isomorphism datatype
  syn_typedefs(code);

  for (auto& func : code.func_entities()) {
    // pass predefs
    if (func.get().is_predef()) {
      continue;
    }

    if (func.get().template_args().empty()) {
      syn_func(func, false);
    } else {
      syn_func(func, true);
    }
  }
  out_.get() << "// generated by HOL2Cpp" << endl;
}

void
Synthesizer::syn_impl(const Code& code)
{
  out_ = ref(impl_out_);

  "#include \"$\"\n\n"_fs.outf(
    out_.get(), filename_.substr(filename_.rfind('/') + 1) + ".hpp");

  for (auto& func : code.func_entities()) {
    // pass predefs
    if (func.get().is_predef()) {
      continue;
    }

    if (func.get().template_args().empty()) {
      syn_func(func);
    }
  }

  out_.get() << "// generated by HOL2Cpp" << endl;
}

void 
Synthesizer::syn_typedefs(const Code& code)
{
  for(auto def_ptr:code.iso_typedef()){
    //对单个同构，直接查找
    for(auto& datatype : code.datatypes()){
      //pass predefs
      if(datatype.get().is_predef()){
        continue;
      }
      //在ast中找到该类型对应类型的code结构
      if(datatype.get().name() == def_ptr.second){
        syn_single_typedef(def_ptr.first,datatype);
      }
    }
  }
  "\n\n"_fs.outf(out_.get());
}

void 
Synthesizer::syn_single_typedef(const string& other_name, const Datatype& datatype)
{
  if (!datatype.is_normal_type()){
    syn_single_typedef_template(other_name, datatype);
  }
  syn_single_typedef_definition(other_name, datatype);
}

void
Synthesizer::syn_single_typedef_template(const string& other_name, const Datatype& datatype)
{
  auto& targs = datatype.template_args();
  "template<"_fs.outf(newline());
  for (size_t i = 0; i < targs.size(); ++i) {
    if (i == 0) {
      "typename $"_fs.outf(out_.get(), targs[i]);
    } else {
      ", typename $"_fs.outf(out_.get(), targs[i]);
    }
  }
  ">\n"_fs.outf(out_.get());
}

void 
Synthesizer::syn_single_typedef_definition(const string& other_name, const Datatype& datatype)
{
  "using $ = $;\n"_fs.outf(out_.get(), other_name, datatype.name());
}

ostream&
Synthesizer::newline(int more_indent)
{
  out_.get() << string(indent_ + more_indent, ' ');
  return out_.get();
}

void
Synthesizer::add_indent()
{
  indent_ += theIndentSize;
}

void
Synthesizer::sub_indent()
{
  indent_ -= theIndentSize;
}
} // namespace hol2cpp
