#include "test_before.hpp"

std::uint64_t add(const std::uint64_t &arg1, const std::uint64_t &arg2) {
    // add 0 n = n
    if (arg1 == 0) {
        return arg2;
    }

    // add (Suc m) n = Suc (add m n)
    auto m = arg1 - 1;
    return add(m, arg2) + 1;
}

bool evn(const std::uint64_t &arg1) {
    // evn 0 = True
    if (arg1 == 0) {
        return true;
    }

    // evn (Suc 0) = False
    if (arg1 != 0) {
        if (arg1 - 1 == 0) {
            return false;
        }
    }

    // evn (Suc (Suc n)) = evn n
    auto n = (arg1 - 1) - 1;
    return evn(n);
}

std::uint64_t natofsnat(const std::uint64_t &arg1) {
    // natofsnat sZero = 0
    if (arg1 == 0) {
        return 0;
    }

    // natofsnat (sSucc n) = (natofsnat n) + 1
    auto n = arg1 - 1;
    return natofsnat(n) + 1;
}

std::uint64_t snatofnat(const std::uint64_t &arg1) {
    // snatofnat 0 = sZero
    if (arg1 == 0) {
        return 0;
    }

    // snatofnat (Suc n) = sSucc (snatofnat n)
    auto n = arg1 - 1;
    return snatofnat(n) + 1;
}

std::uint64_t fib(const std::uint64_t &arg1) {
    // fib 0 = 1
    if (arg1 == 0) {
        return 1;
    }

    // fib (Suc 0) = 1
    if (arg1 != 0) {
        if (arg1 - 1 == 0) {
            return 1;
        }
    }

    // fib n = (fib (n - 1)) + (fib (n - 2))
    return fib(arg1 - 1) + fib(arg1 - 2);
}

std::uint64_t sfib(const std::uint64_t &arg1) {
    // sfib sZero = sSucc sZero
    if (arg1 == 0) {
        return 0 + 1;
    }

    // sfib (sSucc sZero) = sSucc sZero
    if (arg1 != 0) {
        if (arg1 - 1 == 0) {
            return 0 + 1;
        }
    }

    // sfib (sSucc (sSucc m)) = add (sfib (sSucc m)) (sfib m)
    auto m = (arg1 - 1) - 1;
    return add(sfib(m + 1), sfib(m));
}

std::uint64_t fact(const std::uint64_t &arg1) {
    // fact 0 = 1
    if (arg1 == 0) {
        return 1;
    }

    // fact n = n * (fact (n - 1))
    return arg1 * fact(arg1 - 1);
}

bool altrue(const std::uint64_t &arg1) {
    // altrue _ = True
    return true;
}

std::deque<std::uint64_t> merge(const std::deque<std::uint64_t> &arg1, const std::deque<std::uint64_t> &arg2) {
    // merge xs [] = xs
    if (arg2.empty()) {
        return arg1;
    }

    // merge [] ys = ys
    if (arg1.empty()) {
        return arg2;
    }

    // merge (x # xs) (y # ys) = If (x \<le> y) (x # (merge xs (y # ys))) (y # (merge (x # xs) ys))
    auto x = arg1.front();
    auto xs = std::deque<std::uint64_t>(arg1.begin() + 1, arg1.end());
    auto y = arg2.front();
    auto ys = std::deque<std::uint64_t>(arg2.begin() + 1, arg2.end());
    std::deque<std::uint64_t> temp0;
    if (x <= y) {
        auto temp1 = ys;
        temp1.push_front(y);
        auto temp2 = merge(xs, temp1);
        temp2.push_front(x);
        temp0 = temp2;
    } else {
        auto temp3 = xs;
        temp3.push_front(x);
        auto temp4 = merge(temp3, ys);
        temp4.push_front(y);
        temp0 = temp4;
    }
    return temp0;
}

std::deque<std::uint64_t> merge_sort(const std::deque<std::uint64_t> &arg1) {
    // merge_sort [] = []
    if (arg1.empty()) {
        return std::deque<std::uint64_t>();
    }

    // merge_sort [x] = [x]
    if (arg1.size() == 1) {
        auto x = arg1[0];
        return std::deque<std::uint64_t>{x};
    }

    // merge_sort xs = merge (merge_sort (take ((length xs) div 2) xs)) (merge_sort (drop ((length xs) div 2) xs))
    return merge(merge_sort(std::deque<std::uint64_t>(arg1.begin(), arg1.begin() + arg1.size() / 2)), merge_sort(std::deque<std::uint64_t>(arg1.begin() + arg1.size() / 2, arg1.end())));
}

// generated by HOL2Cpp
