#include "test_all_move.hpp"

std::uint64_t add(const std::uint64_t &arg1, const std::uint64_t &arg2) {
    // add sZero n = n
    if (arg1 == 0) {
        return arg2;
    }

    // add (sSucc m) n = sSucc (add m n)
    auto m = arg1 - 1;
    auto temp0 = m;
    auto temp1 = arg2;
    return add(std::move(temp0), std::move(temp1)) + 1;
}

bool evn(const std::uint64_t &arg1) {
    // evn 0 = True
    if (arg1 == 0) {
        return true;
    }

    // evn (Suc 0) = False
    if (arg1 != 0) {
        if (arg1 - 1 == 0) {
            return false;
        }
    }

    // evn (Suc (Suc n)) = evn n
    auto n = (arg1 - 1) - 1;
    auto temp0 = n;
    return evn(std::move(temp0));
}

std::uint64_t natofsnat(const std::uint64_t &arg1) {
    // natofsnat sZero = 0
    if (arg1 == 0) {
        return 0;
    }

    // natofsnat (sSucc n) = (natofsnat n) + 1
    auto n = arg1 - 1;
    auto temp0 = n;
    return natofsnat(std::move(temp0)) + 1;
}

std::uint64_t snatofnat(const std::uint64_t &arg1) {
    // snatofnat 0 = sZero
    if (arg1 == 0) {
        return 0;
    }

    // snatofnat (Suc n) = sSucc (snatofnat n)
    auto n = arg1 - 1;
    auto temp0 = n;
    return snatofnat(std::move(temp0)) + 1;
}

std::uint64_t fib(const std::uint64_t &arg1) {
    // fib 0 = 1
    if (arg1 == 0) {
        return 1;
    }

    // fib (Suc 0) = 1
    if (arg1 != 0) {
        if (arg1 - 1 == 0) {
            return 1;
        }
    }

    // fib n = (fib (n - 1)) + (fib (n - 2))
    auto temp0 = arg1 - 2;
    auto temp1 = arg1 - 1;
    return fib(std::move(temp1)) + fib(std::move(temp0));
}

std::uint64_t sfib(const std::uint64_t &arg1) {
    // sfib sZero = sSucc sZero
    if (arg1 == 0) {
        return 0 + 1;
    }

    // sfib (sSucc sZero) = sSucc sZero
    if (arg1 != 0) {
        if (arg1 - 1 == 0) {
            return 0 + 1;
        }
    }

    // sfib (sSucc (sSucc m)) = add (sfib (sSucc m)) (sfib m)
    auto m = (arg1 - 1) - 1;
    auto temp1 = m + 1;
    auto temp0 = sfib(std::move(temp1));
    auto temp3 = m;
    auto temp2 = sfib(std::move(temp3));
    return add(std::move(temp0), std::move(temp2));
}

bool altrue(const std::uint64_t &arg1) {
    // altrue _ = True
    return true;
}

std::deque<std::uint64_t> merge(std::deque<std::uint64_t> arg1, std::deque<std::uint64_t> arg2) {
    // merge xs [] = xs
    if (arg2.empty()) {
        return arg1;
    }

    // merge [] ys = ys
    if (arg1.empty()) {
        return arg2;
    }

    // merge (x # xs) (y # ys) = If (x \<le> y) (x # (merge xs (y # ys))) (y # (merge (x # xs) ys))
    auto x = arg1.front();
    arg1.erase(arg1.begin(), arg1.begin() + 1);
    auto xs = std::move(arg1);
    auto y = arg2.front();
    arg2.erase(arg2.begin(), arg2.begin() + 1);
    auto ys = std::move(arg2);
    std::deque<std::uint64_t> temp0;
    if (x <= y) {
        auto temp1 = std::move(xs);
        auto temp3 = std::move(ys);
        temp3.push_front(y);
        auto temp2 = std::move(temp3);
        auto temp4 = merge(std::move(temp1), std::move(temp2));
        temp4.push_front(x);
        temp0 = std::move(temp4);
    } else {
        auto temp6 = std::move(xs);
        temp6.push_front(x);
        auto temp5 = std::move(temp6);
        auto temp7 = std::move(ys);
        auto temp8 = merge(std::move(temp5), std::move(temp7));
        temp8.push_front(y);
        temp0 = std::move(temp8);
    }
    return temp0;
}

std::deque<std::uint64_t> merge_sort(std::deque<std::uint64_t> arg1) {
    // merge_sort [] = []
    if (arg1.empty()) {
        return std::deque<std::uint64_t>();
    }

    // merge_sort [x] = [x]
    if (arg1.size() == 1) {
        auto x = arg1[0];
        return std::deque<std::uint64_t>{x};
    }

    // merge_sort xs = merge (merge_sort (take ((length xs) div 2) xs)) (merge_sort (drop ((length xs) div 2) xs))
    auto temp1 = std::deque<std::uint64_t>(arg1.begin(), arg1.begin() + arg1.size() / 2);
    auto temp0 = merge_sort(std::move(temp1));
    auto temp4 = arg1.size() / 2;
    auto temp5 = std::move(arg1);
    temp5.erase(temp5.begin(), std::next(temp5.begin(), temp4));
    auto temp3 = std::move(temp5);
    auto temp2 = merge_sort(std::move(temp3));
    return merge(std::move(temp0), std::move(temp2));
}

// generated by HOL2Cpp
