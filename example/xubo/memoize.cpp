#include "memoize.hpp"

std::uint64_t fib(const std::uint64_t &arg1) {
    auto impl = [&]() -> std::uint64_t {
        // fib 0 = 1
        if (arg1 == 0) {
            return 1;
        }

        // fib (Suc 0) = 1
        if (arg1 != 0) {
            if (arg1 - 1 == 0) {
                return 1;
            }
        }

        // fib n = (fib (n - 1)) + (fib (n - 2))
        return fib(arg1 - 1) + fib(arg1 - 2);
    };

    static std::map<std::tuple<std::uint64_t>, std::uint64_t> cache;
    auto args = std::make_tuple(arg1);
    auto it = cache.find(args);
    return it != cache.end() ? it->second : (cache.emplace(std::move(args), impl()).first->second);
}

std::uint64_t fact(const std::uint64_t &arg1) {
    auto impl = [&]() -> std::uint64_t {
        // fact 0 = 1
        if (arg1 == 0) {
            return 1;
        }

        // fact n = n * (fact (n - 1))
        return arg1 * fact(arg1 - 1);
    };

    static std::map<std::tuple<std::uint64_t>, std::uint64_t> cache;
    auto args = std::make_tuple(arg1);
    auto it = cache.find(args);
    return it != cache.end() ? it->second : (cache.emplace(std::move(args), impl()).first->second);
}

snat add(const snat &arg1, const snat &arg2) {
    // add sZero n = n
    if (arg1.is_sZero()) {
        return arg2;
    }

    // add (sSucc m) n = sSucc (add m n)
    auto m = arg1.as_sSucc().p1();
    auto temp0 = snat::sSucc(
        add(m, arg2)
    );
    return temp0;
}

snat sfib(const snat &arg1) {
    auto impl = [&]() -> snat {
        // sfib sZero = sSucc sZero
        if (arg1.is_sZero()) {
            auto temp0 = snat::sSucc(
                snat::sZero()
            );
            return temp0;
        }

        // sfib (sSucc sZero) = sSucc sZero
        if (arg1.is_sSucc()) {
            if (arg1.as_sSucc().p1().is_sZero()) {
                auto temp0 = snat::sSucc(
                    snat::sZero()
                );
                return temp0;
            }
        }

        // sfib (sSucc (sSucc m)) = add (sfib (sSucc m)) (sfib m)
        auto m = arg1.as_sSucc().p1().as_sSucc().p1();
        auto temp0 = snat::sSucc(
            m
        );
        return add(sfib(temp0), sfib(m));
    };

    static std::map<std::tuple<snat>, snat> cache;
    auto args = std::make_tuple(arg1);
    auto it = cache.find(args);
    return it != cache.end() ? it->second : (cache.emplace(std::move(args), impl()).first->second);
}

std::uint64_t natofsnat(const snat &arg1) {
    // natofsnat sZero = 0
    if (arg1.is_sZero()) {
        return 0;
    }

    // natofsnat (sSucc n) = (natofsnat n) + 1
    auto n = arg1.as_sSucc().p1();
    return natofsnat(n) + 1;
}

snat snatofnat(const std::uint64_t &arg1) {
    // snatofnat 0 = sZero
    if (arg1 == 0) {
        return snat::sZero();
    }

    // snatofnat (Suc n) = sSucc (snatofnat n)
    auto n = arg1 - 1;
    auto temp0 = snat::sSucc(
        snatofnat(n)
    );
    return temp0;
}

// generated by HOL2Cpp
