#include <cstdlib>
#include <memory>
#include <variant>

class snat {
    struct _sZero {
        bool operator<(const _sZero &) const { return false; }
    };
    struct _sSucc {
        std::shared_ptr<snat> p1_;

        snat p1() const { return *p1_; }

        bool operator<(const _sSucc &rhs) const {
            return std::tie(*p1_) < std::tie(*rhs.p1_);
        }
    };

    std::variant<_sZero, _sSucc> value_;
    snat(const std::variant<_sZero, _sSucc> &value) : value_(value) {}

  public:
    snat() = default;

    static snat sZero() {
        return snat { _sZero {  } };
    }
    static snat sSucc(const snat &p1) {
        return snat { _sSucc { std::make_shared<snat>(p1) } };
    }

    bool is_sZero() const { return std::holds_alternative<_sZero>(value_); }
    bool is_sSucc() const { return std::holds_alternative<_sSucc>(value_); }

    const _sSucc &as_sSucc() const { return std::get<_sSucc>(value_); }

    bool operator<(const snat &rhs) const { return value_ < rhs.value_; }
};

class sbool {
    struct _Bone {
        bool operator<(const _Bone &) const { return false; }
    };
    struct _Btwo {
        bool operator<(const _Btwo &) const { return false; }
    };
    struct _Bthree {
        bool operator<(const _Bthree &) const { return false; }
    };

    std::variant<_Bone, _Btwo, _Bthree> value_;
    sbool(const std::variant<_Bone, _Btwo, _Bthree> &value) : value_(value) {}

  public:
    sbool() = default;

    static sbool Bone() {
        return sbool { _Bone {  } };
    }
    static sbool Btwo() {
        return sbool { _Btwo {  } };
    }
    static sbool Bthree() {
        return sbool { _Bthree {  } };
    }

    bool is_Bone() const { return std::holds_alternative<_Bone>(value_); }
    bool is_Btwo() const { return std::holds_alternative<_Btwo>(value_); }
    bool is_Bthree() const { return std::holds_alternative<_Bthree>(value_); }

    bool operator<(const sbool &rhs) const { return value_ < rhs.value_; }
};

using pnat = snat;

// generated by HOL2Cpp
