#include "typedef.hpp"

snat add(const snat &arg1, const snat &arg2) {
    // add sZero n = n
    if (arg1.is_sZero()) {
        return arg2;
    }

    // add (sSucc m) n = sSucc (add m n)
    auto m = arg1.as_sSucc().p1();
    auto temp0 = snat::sSucc(
        add(m, arg2)
    );
    return temp0;
}

std::uint64_t natofsnat(const snat &arg1) {
    // natofsnat sZero = 0
    if (arg1.is_sZero()) {
        return 0;
    }

    // natofsnat (sSucc n) = (natofsnat n) + 1
    auto n = arg1.as_sSucc().p1();
    return natofsnat(n) + 1;
}

snat snatofnat(const std::uint64_t &arg1) {
    // snatofnat 0 = sZero
    if (arg1 == 0) {
        return snat::sZero();
    }

    // snatofnat (Suc n) = sSucc (snatofnat n)
    auto n = arg1 - 1;
    auto temp0 = snat::sSucc(
        snatofnat(n)
    );
    return temp0;
}

std::uint64_t fib(const std::uint64_t &arg1) {
    // fib 0 = 1
    if (arg1 == 0) {
        return 1;
    }

    // fib (Suc 0) = 1
    if (arg1 != 0) {
        if (arg1 - 1 == 0) {
            return 1;
        }
    }

    // fib n = (fib (n - 1)) + (fib (n - 2))
    return fib(arg1 - 1) + fib(arg1 - 2);
}

snat sfib(const snat &arg1) {
    // sfib sZero = sSucc sZero
    if (arg1.is_sZero()) {
        auto temp0 = snat::sSucc(
            snat::sZero()
        );
        return temp0;
    }

    // sfib (sSucc sZero) = sSucc sZero
    if (arg1.is_sSucc()) {
        if (arg1.as_sSucc().p1().is_sZero()) {
            auto temp0 = snat::sSucc(
                snat::sZero()
            );
            return temp0;
        }
    }

    // sfib (sSucc (sSucc m)) = add (sfib (sSucc m)) (sfib m)
    auto m = arg1.as_sSucc().p1().as_sSucc().p1();
    auto temp0 = snat::sSucc(
        m
    );
    return add(sfib(temp0), sfib(m));
}

std::deque<std::uint64_t> merge(std::deque<std::uint64_t> arg1, std::deque<std::uint64_t> arg2) {
    // merge xs [] = xs
    if (arg2.empty()) {
        return arg1;
    }

    // merge [] ys = ys
    if (arg1.empty()) {
        return arg2;
    }

    // merge (x # xs) (y # ys) = If (x \<le> y) (x # (merge xs (y # ys))) (y # (merge (x # xs) ys))
    auto x = arg1.front();
    arg1.erase(arg1.begin(), arg1.begin() + 1);
    auto xs = std::move(arg1);
    auto y = arg2.front();
    arg2.erase(arg2.begin(), arg2.begin() + 1);
    auto ys = std::move(arg2);
    std::deque<std::uint64_t> temp0;
    if (x <= y) {
        auto temp1 = std::move(ys);
        temp1.push_front(y);
        auto temp2 = merge(std::move(xs), std::move(temp1));
        temp2.push_front(x);
        temp0 = std::move(temp2);
    } else {
        auto temp3 = std::move(xs);
        temp3.push_front(x);
        auto temp4 = merge(std::move(temp3), std::move(ys));
        temp4.push_front(y);
        temp0 = std::move(temp4);
    }
    return temp0;
}

std::deque<std::uint64_t> merge_sort(std::deque<std::uint64_t> arg1) {
    // merge_sort [] = []
    if (arg1.empty()) {
        return std::deque<std::uint64_t>();
    }

    // merge_sort [x] = [x]
    if (arg1.size() == 1) {
        auto x = arg1[0];
        return std::deque<std::uint64_t>{x};
    }

    // merge_sort xs = merge (merge_sort (take ((length xs) div 2) xs)) (merge_sort (drop ((length xs) div 2) xs))
    return merge(merge_sort(std::deque<std::uint64_t>(arg1.begin(), arg1.begin() + arg1.size() / 2)), merge_sort(std::deque<std::uint64_t>(arg1.begin() + arg1.size() / 2, arg1.end())));
}

// generated by HOL2Cpp
